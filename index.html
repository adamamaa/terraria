<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>간단한 테라리아 스타일 게임 (WASD 이동)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        body { display: flex; justify-content: center; align-items: center; min-height: 100vh; background-color: #333; margin: 0; font-family: 'Arial', sans-serif; flex-direction: column; color: #eee; }
        canvas { border: 2px solid #888; background-color: #87CEEB; display: block; box-shadow: 0 4px 12px rgba(0,0,0,0.4); cursor: crosshair; }
        #ui-container { margin-top: 15px; padding: 12px; background-color: rgba(50, 50, 50, 0.9); border-radius: 10px; box-shadow: 0 2px 5px rgba(0,0,0,0.2); text-align: center; border: 1px solid #555; width: 90%; max-width: 750px; }
        #controls button { padding: 10px 18px; margin: 5px; font-size: 15px; cursor: pointer; border: none; border-radius: 6px; background-color: #555; color: #eee; transition: background-color 0.2s, box-shadow 0.2s, transform 0.1s; box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
        #controls button:hover { background-color: #666; box-shadow: 0 3px 6px rgba(0,0,0,0.3); }
        #controls button.active { background-color: #0ea5e9; color: white; box-shadow: inset 0 2px 4px rgba(0,0,0,0.3); border: 1px solid #0284c7; }
        #controls button:active { transform: translateY(1px); box-shadow: 0 1px 2px rgba(0,0,0,0.2); }
        .info-box { margin-top: 10px; font-size: 14px; color: #ddd; background-color: #444; padding: 8px 12px; border-radius: 5px; display: inline-block; min-width: 90px; margin: 5px; vertical-align: top; border: 1px solid #666; text-align: left; }
        #status-info { font-weight: bold; color: #38bdf8; }
        #inventory-display { width: auto; }
        #inventory-display span { margin: 0 4px; font-weight: bold; white-space: nowrap; display: inline-block; }
        #sound-status { font-size: 12px; color: #888; margin-top: 5px; }
        #coords-info { font-size: 12px; color: #aaa; margin-top: 5px; }
        #health-display { font-weight: bold; color: #f87171; position: relative; border: 1px solid #ef4444; background-color: #dc2626; height: 20px; line-height: 20px; text-align: center; overflow: hidden; }
        #health-bar-inner { position: absolute; top: 0; left: 0; height: 100%; background-color: #f87171; transition: width 0.2s ease-out; z-index: 1; }
        #health-text { position: relative; z-index: 2; color: white; mix-blend-mode: difference; padding: 0 5px; }
        #game-over-message { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 48px; color: red; background-color: rgba(0, 0, 0, 0.7); padding: 20px; border-radius: 10px; display: none; z-index: 100; text-align: center; }
    </style>
</head>
<body>
    <div style="position: relative;">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div id="game-over-message">게임 오버!<br><small style="font-size: 20px;">(새로고침하여 다시 시작)</small></div>
    </div>
    <div id="ui-container">
        <div id="controls">
            <button id="breakBtn" class="active">⛏️ 파괴</button>
            <button id="placeDirtBtn">🧱 흙 놓기</button>
            <button id="placeStoneBtn">🪨 돌 놓기</button>
            <button id="placeWoodBtn">🪵 나무 놓기</button>
        </div>
        <div>
             <div id="status-info" class="info-box">현재 모드: 파괴</div>
             <div id="block-info" class="info-box">마우스: (0, 0) | 블록: 공기</div>
             <div id="health-display" class="info-box">
                <div id="health-bar-inner"></div><span id="health-text">체력: 100/100</span>
             </div>
        </div>
        <div id="inventory-display" class="info-box">
             </div>
         <div id="sound-status">화면을 클릭하면 소리가 활성화됩니다.</div>
         <div id="coords-info">플레이어 좌표: (0, 0)</div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        // UI Elements... (same)
        const controlsDiv = document.getElementById('controls');
        const breakBtn = document.getElementById('breakBtn');
        const placeDirtBtn = document.getElementById('placeDirtBtn');
        const placeStoneBtn = document.getElementById('placeStoneBtn');
        const placeWoodBtn = document.getElementById('placeWoodBtn');
        const blockInfoDiv = document.getElementById('block-info');
        const statusInfoDiv = document.getElementById('status-info');
        const inventoryDisplayDiv = document.getElementById('inventory-display');
        const soundStatusDiv = document.getElementById('sound-status');
        const coordsInfoDiv = document.getElementById('coords-info');
        const healthDisplayDiv = document.getElementById('health-display');
        const healthBarInner = document.getElementById('health-bar-inner');
        const healthText = document.getElementById('health-text');
        const gameOverMessage = document.getElementById('game-over-message');

        // --- Game Settings --- (same)
        const TILE_SIZE = 20;
        const WORLD_WIDTH_TILES = 200; const WORLD_HEIGHT_TILES = 150;
        const GRAVITY = 0.5; const JUMP_FORCE = -10; const PLAYER_SPEED = 4; const REACH_DISTANCE_TILES = 4;
        const MAX_FALL_VELOCITY_FOR_DAMAGE = 12; const FALL_DAMAGE_MULTIPLIER = 2;
        const DAY_CYCLE_LENGTH_SECONDS = 60 * 5;
        const ENEMY_SPAWN_RATE = 180; const MAX_ENEMIES = 12;
        const ZOMBIE_SPEED = 0.6; const ENEMY_DETECTION_RANGE = TILE_SIZE * 10;

        // --- Block Types, Names, Colors --- (same)
        const BLOCK_TYPES = { AIR: 0, DIRT: 1, STONE: 2, GRASS: 3, WOOD: 4, LEAVES: 5, COPPER: 6, IRON: 7, GOLD: 8 };
        const BLOCK_NAMES = { [BLOCK_TYPES.AIR]: "공기", [BLOCK_TYPES.DIRT]: "흙", [BLOCK_TYPES.STONE]: "돌", [BLOCK_TYPES.GRASS]: "잔디", [BLOCK_TYPES.WOOD]: "나무", [BLOCK_TYPES.LEAVES]: "나뭇잎", [BLOCK_TYPES.COPPER]: "구리 광석", [BLOCK_TYPES.IRON]: "철 광석", [BLOCK_TYPES.GOLD]: "금 광석" };
        const BLOCK_COLORS = { [BLOCK_TYPES.AIR]: '#87CEEB', [BLOCK_TYPES.DIRT]: '#A0522D', [BLOCK_TYPES.STONE]: '#778899', [BLOCK_TYPES.GRASS]: '#2E8B57', [BLOCK_TYPES.WOOD]: '#8B4513', [BLOCK_TYPES.LEAVES]: '#556B2F', [BLOCK_TYPES.COPPER]: '#B87333', [BLOCK_TYPES.IRON]: '#A19D94', [BLOCK_TYPES.GOLD]: '#FFD700' };

        // --- Game State --- (same)
        let world = [];
        let player = { x: 0, y: 0, width: TILE_SIZE * 0.8, height: TILE_SIZE * 1.8, vx: 0, vy: 0, onGround: false, health: 100, maxHealth: 100, invulnerableTimer: 0 };
        let keys = {};
        let currentTool = 'break'; let selectedBlockToPlace = BLOCK_TYPES.DIRT;
        let mouseScreenPos = { x: 0, y: 0 }; let mouseWorldPos = { x: 0, y: 0 }; let mouseTile = { x: 0, y: 0 };
        let breakParticles = []; let clouds = [];
        let inventory = { [BLOCK_TYPES.DIRT]: 10, [BLOCK_TYPES.STONE]: 5, [BLOCK_TYPES.WOOD]: 0, [BLOCK_TYPES.COPPER]: 0, [BLOCK_TYPES.IRON]: 0, [BLOCK_TYPES.GOLD]: 0 };
        let soundInitialized = false; let camera = { x: 0, y: 0 };
        let enemies = []; let gameTime = 0; let isGameOver = false;

        // --- Sound Effects --- (same initSounds)
        let jumpSound, breakSound, placeSound, cantPlaceSound, playerHurtSound, enemyHurtSound, enemyDieSound;
        function initSounds() { Tone.start(); jumpSound = new Tone.Synth({ oscillator: { type: 'triangle' }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.1 } }).toDestination(); breakSound = new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.005, decay: 0.05, sustain: 0, release: 0.1 } }).toDestination(); breakSound.volume.value = -10; placeSound = new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.01, decay: 0.05, sustain: 0.1, release: 0.1 } }).toDestination(); placeSound.volume.value = -6; cantPlaceSound = new Tone.Synth({ oscillator: { type: 'square' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0, release: 0.1 } }).toDestination(); cantPlaceSound.volume.value = -15; playerHurtSound = new Tone.Synth({ oscillator: { type: 'sawtooth' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0, release: 0.1 } }).toDestination(); playerHurtSound.volume.value = -8; enemyHurtSound = new Tone.Synth({ oscillator: { type: 'square' }, envelope: { attack: 0.01, decay: 0.1, sustain: 0, release: 0.1 } }).toDestination(); enemyHurtSound.volume.value = -12; enemyDieSound = new Tone.NoiseSynth({ noise: { type: 'pink' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0, release: 0.2 } }).toDestination(); enemyDieSound.volume.value = -8; console.log("Sounds initialized."); soundStatusDiv.textContent = "소리 활성화됨"; soundInitialized = true; }

        // --- Particle System --- (same)
        class Particle { constructor(x, y, color) { this.x = x; this.y = y; this.size = Math.random() * 3 + 1; this.vx = (Math.random() - 0.5) * 2; this.vy = (Math.random() - 0.5) * 2 - 1; this.life = 30; this.color = color; } update() { this.x += this.vx; this.y += this.vy; this.vy += 0.1; this.life--; } draw() { ctx.fillStyle = this.color; ctx.globalAlpha = Math.max(0, this.life / 30); ctx.fillRect(this.x - camera.x - this.size / 2, this.y - camera.y - this.size / 2, this.size, this.size); ctx.globalAlpha = 1.0; } }
        function updateParticles() { for (let i = breakParticles.length - 1; i >= 0; i--) { breakParticles[i].update(); if (breakParticles[i].life <= 0) breakParticles.splice(i, 1); } }
        function drawParticles() { breakParticles.forEach(p => p.draw()); }

        // --- Cloud Generation/Drawing --- (same)
        function generateClouds() { clouds = []; for (let i = 0; i < 30; i++) { clouds.push({ x: Math.random() * WORLD_WIDTH_TILES * TILE_SIZE, y: Math.random() * (WORLD_HEIGHT_TILES * TILE_SIZE * 0.4), size: Math.random() * 50 + 30, speed: Math.random() * 0.3 + 0.1 }); } }
        function updateClouds() { clouds.forEach(cloud => { cloud.x += cloud.speed; if (cloud.x > WORLD_WIDTH_TILES * TILE_SIZE + cloud.size) { cloud.x = -cloud.size; cloud.y = Math.random() * (WORLD_HEIGHT_TILES * TILE_SIZE * 0.4); } }); }
        function drawClouds() { ctx.fillStyle = 'rgba(255, 255, 255, 0.8)'; clouds.forEach(cloud => { const screenX = cloud.x - camera.x; const screenY = cloud.y - camera.y; if (screenX + cloud.size > 0 && screenX < canvas.width && screenY + cloud.size > 0 && screenY < canvas.height) { ctx.beginPath(); ctx.arc(screenX, screenY, cloud.size * 0.6, Math.PI * 0.5, Math.PI * 1.5); ctx.arc(screenX + cloud.size * 0.4, screenY - cloud.size * 0.2, cloud.size * 0.4, Math.PI * 1, Math.PI * 2); ctx.arc(screenX + cloud.size * 0.8, screenY, cloud.size * 0.6, Math.PI * 1.5, Math.PI * 0.5); ctx.closePath(); ctx.fill(); } }); }

        // --- World Generation --- (same functions)
        function generateWorld() { console.log(`Generating world (${WORLD_WIDTH_TILES}x${WORLD_HEIGHT_TILES})...`); world = Array(WORLD_HEIGHT_TILES).fill(null).map(() => Array(WORLD_WIDTH_TILES).fill(BLOCK_TYPES.AIR)); const groundLevel = Math.floor(WORLD_HEIGHT_TILES * 0.3); const stoneDepth = groundLevel + 5; for (let y = 0; y < WORLD_HEIGHT_TILES; y++) { for (let x = 0; x < WORLD_WIDTH_TILES; x++) { const depth = y - groundLevel; const randomFactor = Math.random(); const stoneNoise = Math.sin(x / 18) * 2 + Math.sin(y / 15) * 2; if (y > groundLevel) { if (y > stoneDepth + stoneNoise) { world[y][x] = BLOCK_TYPES.STONE; } else { world[y][x] = BLOCK_TYPES.DIRT; } } } } generateCaves(groundLevel); for (let x = 0; x < WORLD_WIDTH_TILES; x++) { for (let y = 1; y < WORLD_HEIGHT_TILES; y++) { if (world[y][x] === BLOCK_TYPES.DIRT && world[y-1][x] === BLOCK_TYPES.AIR) { world[y][x] = BLOCK_TYPES.GRASS; } } } generateOres(groundLevel); for (let x = 5; x < WORLD_WIDTH_TILES - 5; x++) { if (Math.random() < 0.05) { for (let y = groundLevel - 5; y < groundLevel + 5; y++) { if (y >= 0 && y < WORLD_HEIGHT_TILES && world[y][x] === BLOCK_TYPES.GRASS) { generateTree(x, y - 1); x += Math.floor(Math.random() * 5) + 3; break; } } } } console.log("World generation complete."); generateClouds(); }
        function generateCaves(surfaceLevel) { const numCaves = Math.floor(WORLD_WIDTH_TILES * WORLD_HEIGHT_TILES / 1800); const maxCaveLength = 200; const minCaveLength = 60; const baseThickness = 2; console.log(`Generating ${numCaves} caves...`); for (let i = 0; i < numCaves; i++) { let currentX = Math.floor(Math.random() * WORLD_WIDTH_TILES); let currentY = Math.floor(Math.random() * (WORLD_HEIGHT_TILES - surfaceLevel - 20)) + surfaceLevel + 10; let caveLength = Math.floor(Math.random() * (maxCaveLength - minCaveLength + 1)) + minCaveLength; let direction = Math.random() * Math.PI * 2; let currentThickness = baseThickness; for (let j = 0; j < caveLength; j++) { for (let dx = -currentThickness; dx <= currentThickness; dx++) { for (let dy = -currentThickness; dy <= currentThickness; dy++) { if (dx * dx + dy * dy <= currentThickness * currentThickness) { const carveX = Math.round(currentX + dx); const carveY = Math.round(currentY + dy); if (carveX >= 0 && carveX < WORLD_WIDTH_TILES && carveY >= 0 && carveY < WORLD_HEIGHT_TILES) { if (carveY > surfaceLevel + 3) { world[carveY][carveX] = BLOCK_TYPES.AIR; } } } } } direction += (Math.random() - 0.5) * 1.2; if (Math.random() < 0.03) { direction = Math.random() * Math.PI * 2; } if (Math.sin(direction) > 0.5) { direction = direction * 0.8 + (Math.random() * Math.PI * 0.2) * 0.2; } if (Math.random() < 0.15) { currentThickness += (Math.random() < 0.5 ? -1 : 1); currentThickness = Math.max(1, Math.min(4, currentThickness)); } currentX += Math.cos(direction) * 1.5; currentY += Math.sin(direction) * 1.5; if (currentX < -10 || currentX > WORLD_WIDTH_TILES + 10 || currentY < surfaceLevel - 10 || currentY > WORLD_HEIGHT_TILES + 10) break; } } console.log("Cave generation finished."); }
        function generateOres(surfaceLevel) { console.log("Generating ores..."); const copperChance = 0.015; const ironChance = 0.01; const goldChance = 0.005; const copperDepth = surfaceLevel + 5; const ironDepth = surfaceLevel + 20; const goldDepth = surfaceLevel + 40; for (let y = surfaceLevel; y < WORLD_HEIGHT_TILES; y++) { for (let x = 0; x < WORLD_WIDTH_TILES; x++) { if (world[y][x] === BLOCK_TYPES.STONE) { let oreType = null; let chance = Math.random(); if (y > goldDepth && chance < goldChance * (y / WORLD_HEIGHT_TILES)) oreType = BLOCK_TYPES.GOLD; else if (y > ironDepth && chance < ironChance * (y / (WORLD_HEIGHT_TILES * 0.8))) oreType = BLOCK_TYPES.IRON; else if (y > copperDepth && chance < copperChance) oreType = BLOCK_TYPES.COPPER; if (oreType !== null) placeOreVein(x, y, oreType); } } } console.log("Ore generation finished."); }
        function placeOreVein(startX, startY, oreType) { const veinSize = Math.floor(Math.random() * 4) + 2; let placedCount = 0; let currentX = startX; let currentY = startY; for (let i = 0; i < veinSize * 2 && placedCount < veinSize; i++) { if (currentX >= 0 && currentX < WORLD_WIDTH_TILES && currentY >= 0 && currentY < WORLD_HEIGHT_TILES) { if (world[currentY][currentX] === BLOCK_TYPES.STONE) { world[currentY][currentX] = oreType; placedCount++; } } const move = Math.floor(Math.random() * 4); if (move === 0) currentX++; else if (move === 1) currentX--; else if (move === 2) currentY++; else if (move === 3) currentY--; if(Math.random() < 0.3) { currentX = Math.round(currentX * 0.8 + startX * 0.2); currentY = Math.round(currentY * 0.8 + startY * 0.2); } } }
        function generateTree(x, y) { const minTrunkHeight = 3; const maxTrunkHeight = 6; const trunkHeight = Math.floor(Math.random() * (maxTrunkHeight - minTrunkHeight + 1)) + minTrunkHeight; let canPlaceTrunk = true; for (let i = 0; i < trunkHeight; i++) { if (y - i < 0 || world[y - i][x] !== BLOCK_TYPES.AIR) { canPlaceTrunk = false; break; } } if (!canPlaceTrunk) return; for (let i = 0; i < trunkHeight; i++) { if (y - i >= 0) world[y - i][x] = BLOCK_TYPES.WOOD; } const canopyRadius = 2; const canopyY = y - trunkHeight; for (let ly = -canopyRadius; ly <= 1; ly++) { for (let lx = -canopyRadius; lx <= canopyRadius; lx++) { if (Math.abs(lx) === canopyRadius && Math.abs(ly) >= canopyRadius -1) continue; if (Math.abs(lx) >= canopyRadius && Math.abs(ly) === 1) continue; const leafX = x + lx; const leafY = canopyY + ly; if (leafX >= 0 && leafX < WORLD_WIDTH_TILES && leafY >= 0 && leafY < WORLD_HEIGHT_TILES) { if (world[leafY][leafX] === BLOCK_TYPES.AIR) world[leafY][leafX] = BLOCK_TYPES.LEAVES; } } } }

        // --- Collision Detection --- (same functions as user provided)
        function getTile(worldX, worldY) { const tileX = Math.floor(worldX / TILE_SIZE); const tileY = Math.floor(worldY / TILE_SIZE); if (tileX >= 0 && tileX < WORLD_WIDTH_TILES && tileY >= 0 && tileY < WORLD_HEIGHT_TILES) return world[tileY][tileX]; return BLOCK_TYPES.STONE; }
        function isSolid(blockType) { return blockType !== BLOCK_TYPES.AIR && blockType !== BLOCK_TYPES.LEAVES; }
        function checkCollision(x, y, width, height, checkEnemies = false) { const epsilon = 0.01; const checkPoints = [ { x: x + epsilon, y: y + epsilon }, { x: x + width - epsilon, y: y + epsilon }, { x: x + epsilon, y: y + height - epsilon }, { x: x + width - epsilon, y: y + height - epsilon }, { x: x + width / 2, y: y + epsilon }, { x: x + width / 2, y: y + height - epsilon }, { x: x + epsilon, y: y + height / 2 }, { x: x + width - epsilon, y: y + height / 2 } ]; for (const point of checkPoints) { if (isSolid(getTile(point.x, point.y))) return true; } if (checkEnemies) { for (const enemy of enemies) { const enemyRect = { x: enemy.x, y: enemy.y, width: enemy.width, height: enemy.height }; const playerRect = { x: x, y: y, width: width, height: height }; if (rectsOverlap(playerRect, enemyRect)) return true; } } return false; }
        function checkEntityCollision(entity, offsetX = 0, offsetY = 0) { const x = entity.x + offsetX; const y = entity.y + offsetY; const width = entity.width; const height = entity.height; const epsilon = 0.01; const checkPoints = [ { x: x + epsilon, y: y + epsilon }, { x: x + width - epsilon, y: y + epsilon }, { x: x + epsilon, y: y + height - epsilon }, { x: x + width - epsilon, y: y + height - epsilon }, { x: x + width / 2, y: y + epsilon }, { x: x + width / 2, y: y + height - epsilon }, { x: x + epsilon, y: y + height / 2 }, { x: x + width - epsilon, y: y + height / 2 } ]; for (const point of checkPoints) { if (isSolid(getTile(point.x, point.y))) return true; } return false; }
        function handleCollisions() { let landingVelocity = 0; player.onGround = false; let isStuck = checkCollision(player.x, player.y, player.width, player.height, false); if (isStuck) { unstuckPlayer(); } let nextX = player.x + player.vx; if (checkCollision(nextX, player.y, player.width, player.height, false)) { if (player.vx > 0) { player.x = Math.floor((nextX + player.width) / TILE_SIZE) * TILE_SIZE - player.width - 0.01; } else if (player.vx < 0) { player.x = Math.floor(nextX / TILE_SIZE + 1) * TILE_SIZE + 0.01; } player.vx = 0; } else { player.x = nextX; } let nextY = player.y + player.vy; if (checkCollision(player.x, nextY, player.width, player.height, false)) { landingVelocity = player.vy; if (player.vy > 0) { player.y = Math.floor((nextY + player.height) / TILE_SIZE) * TILE_SIZE - player.height; player.onGround = true; player.vy = 0; } else if (player.vy < 0) { player.y = Math.floor(nextY / TILE_SIZE + 1) * TILE_SIZE; player.vy = 0; } } else { player.y = nextY; } if (player.onGround && landingVelocity > MAX_FALL_VELOCITY_FOR_DAMAGE) { const damage = Math.floor((landingVelocity - MAX_FALL_VELOCITY_FOR_DAMAGE) * FALL_DAMAGE_MULTIPLIER); console.log(`Fall damage: ${damage}, Velocity: ${landingVelocity}`); damagePlayer(damage); } if (player.invulnerableTimer <= 0) { for (const enemy of enemies) { const enemyRect = { x: enemy.x, y: enemy.y, width: enemy.width, height: enemy.height }; const playerRect = { x: player.x, y: player.y, width: player.width, height: player.height }; if (rectsOverlap(playerRect, enemyRect)) { damagePlayer(enemy.damage); player.invulnerableTimer = 60; break; } } } else { player.invulnerableTimer--; } }
        function unstuckPlayer() { const directions = [ { dx: 0, dy: -1 }, { dx: 1, dy: -1 }, { dx: 1, dy: 0 }, { dx: 1, dy: 1 }, { dx: 0, dy: 1 }, { dx: -1, dy: 1 }, { dx: -1, dy: 0 }, { dx: -1, dy: -1 } ]; for (let dist = 1; dist <= TILE_SIZE; dist++) { for (const dir of directions) { const testX = player.x + dir.dx * dist; const testY = player.y + dir.dy * dist; if (!checkCollision(testX, testY, player.width, player.height, false)) { console.log(`Player was stuck - nudged ${dist} pixels to escape`); player.x = testX; player.y = testY; player.vx = 0; player.vy = 0; return; } } } console.warn("Player severely stuck - attempting reset to world start"); const startTileX = Math.floor(WORLD_WIDTH_TILES / 2); const startGroundY = Math.floor(WORLD_HEIGHT_TILES * 0.3); let resetY = (startGroundY - 5) * TILE_SIZE; for (let y = 0; y < WORLD_HEIGHT_TILES; y++) { if (isSolid(world[y][startTileX]) && !isSolid(world[y-1][startTileX]) && !isSolid(world[y-2][startTileX])) { resetY = (y - 2) * TILE_SIZE; break; } } player.x = startTileX * TILE_SIZE; player.y = resetY; player.vx = 0; player.vy = 0; }
        function unstuckEnemy(enemy) { const directions = [ { dx: 0, dy: -1 }, { dx: 1, dy: -1 }, { dx: 1, dy: 0 }, { dx: 1, dy: 1 }, { dx: 0, dy: 1 }, { dx: -1, dy: 1 }, { dx: -1, dy: 0 }, { dx: -1, dy: -1 } ]; for (let dist = 1; dist <= 15; dist++) { for (const dir of directions) { const testX = enemy.x + dir.dx * dist; const testY = enemy.y + dir.dy * dist; if (!checkEntityCollision({x: testX, y: testY, width: enemy.width, height: enemy.height})) { console.log(`Enemy unstuck: Moved ${dist} pixels ${dir.dx},${dir.dy}`); enemy.x = testX; enemy.y = testY; enemy.vx = 0; enemy.vy = 0; return true; } } } return false; }

        // --- Player Damage & Game Over --- (same functions)
        function damagePlayer(amount) { if (isGameOver || player.invulnerableTimer > 0) return; player.health -= amount; player.health = Math.max(0, player.health); console.log(`Player took ${amount} damage, health: ${player.health}`); updateHealthUI(); if (soundInitialized) playerHurtSound.triggerAttackRelease('A3', '8n'); if (player.health <= 0) gameOver(); }
        function gameOver() { console.log("Game Over!"); isGameOver = true; gameOverMessage.style.display = 'block'; player.vx = 0; player.vy = 0; }
        function updateHealthUI() { const healthPercentage = (player.health / player.maxHealth) * 100; healthBarInner.style.width = `${healthPercentage}%`; healthText.textContent = `체력: ${player.health}/${player.maxHealth}`; }

        // --- Enemy Implementation (Replaced with User Provided Class) ---
        class Enemy {
            constructor(x, y, type = 'slime') { this.x = x; this.y = y; this.type = type; this.onGround = false; this.vy = 0; this.stuckCounter = 0; if (type === 'zombie') { this.width = TILE_SIZE * 0.8; this.height = TILE_SIZE * 1.8; this.vx = 0; this.health = 50; this.maxHealth = 50; this.damage = 15; this.speed = ZOMBIE_SPEED; } else { this.width = TILE_SIZE * 0.9; this.height = TILE_SIZE * 0.7; this.vx = (Math.random() < 0.5 ? 1 : -1) * (Math.random() * 0.5 + 0.5); this.health = 30; this.maxHealth = 30; this.damage = 10; this.jumpCooldown = Math.random() * 120 + 60; } }
            update() { if (checkEntityCollision(this)) { this.stuckCounter++; if (this.stuckCounter > 3) { if (!unstuckEnemy(this)) { if (this.stuckCounter > 10) { console.log(`Enemy of type ${this.type} severely stuck - removing`); const enemyIndex = enemies.indexOf(this); if (enemyIndex > -1) { enemies.splice(enemyIndex, 1); } return; } } else { this.stuckCounter = 0; return; } } } else { this.stuckCounter = 0; } if (!this.onGround) { this.vy += GRAVITY; } let targetPlayer = false; const dxPlayer = player.x - this.x; const dyPlayer = player.y - this.y; const distPlayer = Math.sqrt(dxPlayer*dxPlayer + dyPlayer*dyPlayer); if (this.type === 'zombie') { if (distPlayer < ENEMY_DETECTION_RANGE) { this.vx = dxPlayer > 0 ? this.speed : -this.speed; targetPlayer = true; } else { if (Math.random() < 0.01) { this.vx = (Math.random() < 0.5 ? 1 : -1) * this.speed * 0.5; } else if (this.vx === 0) { this.vx = (Math.random() < 0.5 ? 1 : -1) * this.speed * 0.5; } } } else { this.jumpCooldown--; if (this.onGround && this.jumpCooldown <= 0) { this.vy = -(Math.random() * 3 + 2); this.onGround = false; this.jumpCooldown = Math.random() * 180 + 120; } if (this.vx === 0) { this.vx = (Math.random() < 0.5 ? 1 : -1) * (Math.random() * 0.5 + 0.5); } } let nextX = this.x + this.vx; let nextY = this.y + this.vy; this.onGround = false; if (checkEntityCollision({x: nextX, y: this.y, width: this.width, height: this.height})) { if (this.vx > 0) { this.x = Math.floor((nextX + this.width) / TILE_SIZE) * TILE_SIZE - this.width - 0.01; } else if (this.vx < 0) { this.x = Math.floor(nextX / TILE_SIZE + 1) * TILE_SIZE + 0.01; } if (!targetPlayer) { this.vx *= -1; } else { this.vx = 0; if (this.type === 'zombie' && this.onGround && Math.random() < 0.3) { this.vy = -5; this.onGround = false; } } } else { this.x = nextX; } if (checkEntityCollision({x: this.x, y: nextY, width: this.width, height: this.height})) { if (this.vy > 0) { this.y = Math.floor((nextY + this.height) / TILE_SIZE) * TILE_SIZE - this.height; this.onGround = true; this.vy = 0; } else if (this.vy < 0) { this.y = Math.floor(nextY / TILE_SIZE + 1) * TILE_SIZE; this.vy = 0; } } else { this.y = nextY; } if (this.onGround && !targetPlayer && this.type === 'slime') { const checkAheadX = this.x + (this.vx > 0 ? this.width + 2 : -2); const tileBelowAhead = getTile(checkAheadX, this.y + this.height + 5); if (!isSolid(tileBelowAhead)) { this.vx *= -1; } } if (this.type === 'zombie' && targetPlayer && this.onGround && Math.abs(this.vx) < 0.1) { if (player.y < this.y - TILE_SIZE && Math.random() < 0.2) { this.vy = -6; this.onGround = false; } } }
            draw() { const screenX = this.x - camera.x; const screenY = this.y - camera.y; if (this.type === 'zombie') { ctx.fillStyle = '#5a6351'; ctx.fillRect(screenX, screenY, this.width, this.height); ctx.fillStyle = '#8a9480'; ctx.fillRect(screenX + this.width * 0.1, screenY + this.height * 0.05, this.width * 0.8, this.height * 0.3); ctx.fillStyle = 'red'; ctx.fillRect(screenX + this.width * 0.3, screenY + this.height * 0.15, 3, 3); ctx.fillRect(screenX + this.width * 0.6, screenY + this.height * 0.15, 3, 3); } else { ctx.fillStyle = '#34D399'; ctx.beginPath(); ctx.arc(screenX + this.width / 2, screenY + this.height * 0.6, this.width / 2, Math.PI, 0); ctx.rect(screenX, screenY + this.height * 0.6, this.width, this.height * 0.4); ctx.fill(); ctx.fillStyle = 'white'; ctx.fillRect(screenX + this.width * 0.3, screenY + this.height * 0.4, 3, 3); ctx.fillRect(screenX + this.width * 0.6, screenY + this.height * 0.4, 3, 3); } if (this.health < this.maxHealth) { const barWidth = this.width * 0.8; const barHeight = 4; const barX = screenX + (this.width - barWidth) / 2; const barY = screenY - barHeight - 2; const healthPercent = this.health / this.maxHealth; ctx.fillStyle = '#555'; ctx.fillRect(barX, barY, barWidth, barHeight); ctx.fillStyle = '#f87171'; ctx.fillRect(barX, barY, barWidth * healthPercent, barHeight); } }
            takeDamage(amount) { this.health -= amount; console.log(`${this.type} took ${amount} damage, health: ${this.health}`); if (soundInitialized) enemyHurtSound.triggerAttackRelease('E4', '16n'); const particleColor = this.type === 'zombie' ? '#5a6351' : '#34D399'; for (let i = 0; i < 3; i++) { breakParticles.push(new Particle(this.x + this.width / 2, this.y + this.height / 2, particleColor)); } }
        }

        // --- Enemy Spawning (Replaced with User Provided Function) ---
        function spawnEnemy() { if (enemies.length >= MAX_ENEMIES) return; const spawnRangeX = canvas.width * 1.5; const spawnRangeY = canvas.height * 1.5; const spawnX = player.x + (Math.random() * spawnRangeX) - (spawnRangeX / 2); const spawnYAttempt = player.y + (Math.random() * spawnRangeY) - (spawnRangeY / 2); const spawnTileX = Math.floor(spawnX / TILE_SIZE); const spawnTileY = Math.floor(spawnYAttempt / TILE_SIZE); if (spawnTileX < 0 || spawnTileX >= WORLD_WIDTH_TILES || spawnTileY < 0 || spawnTileY >= WORLD_HEIGHT_TILES) return; let enemyType = null; const surfaceLevel = Math.floor(WORLD_HEIGHT_TILES * 0.3); const stoneDepth = surfaceLevel + 5; if (getTile(spawnX, spawnYAttempt) === BLOCK_TYPES.AIR && getTile(spawnX, spawnYAttempt + TILE_SIZE) !== BLOCK_TYPES.AIR) { const dx = player.x - spawnX; const dy = player.y - spawnYAttempt; if (Math.sqrt(dx*dx + dy*dy) < TILE_SIZE * 8) return; const finalSpawnY = spawnTileY * TILE_SIZE; if (spawnTileY > stoneDepth + 5) { enemyType = (Math.random() < 0.9) ? 'zombie' : 'slime'; } else if (spawnTileY > surfaceLevel) { enemyType = (Math.random() < 0.6) ? 'zombie' : 'slime'; } else { enemyType = 'slime'; } const tempEntity = { x: spawnX, y: finalSpawnY, width: TILE_SIZE * (enemyType === 'zombie' ? 0.8 : 0.9), height: TILE_SIZE * (enemyType === 'zombie' ? 1.8 : 0.7) }; if (!checkEntityCollision(tempEntity)) { console.log(`Spawning ${enemyType} at (${spawnTileX}, ${spawnTileY})`); enemies.push(new Enemy(spawnX, finalSpawnY, enemyType)); } else { console.log(`Spawn location blocked for ${enemyType} at (${spawnTileX}, ${spawnTileY})`); } } }
        function updateEnemies() { for (let i = enemies.length - 1; i >= 0; i--) { enemies[i].update(); } }
        function drawEnemies() { enemies.forEach(enemy => enemy.draw()); }


        // --- Player Movement --- (Modified handleInput for WASD)
        function handleInput() {
            if(isGameOver) return;
            player.vx = 0;

            // Use 'a' for left
            if (keys['a']) {
                player.vx = -PLAYER_SPEED;
            }
            // Use 'd' for right
            if (keys['d']) {
                player.vx = PLAYER_SPEED;
            }
            // Use 'w' or 'space' for jump
            if ((keys['w'] || keys[' ']) && player.onGround) {
                player.vy = JUMP_FORCE;
                player.onGround = false;
                if (soundInitialized) jumpSound.triggerAttackRelease('C5', '8n');
            }
        }

        // --- Update Camera --- (same updateCamera)
        function updateCamera() { camera.x = player.x - canvas.width / 2 + player.width / 2; camera.y = player.y - canvas.height / 2 + player.height / 2; const maxCameraX = WORLD_WIDTH_TILES * TILE_SIZE - canvas.width; const maxCameraY = WORLD_HEIGHT_TILES * TILE_SIZE - canvas.height; camera.x = Math.max(0, Math.min(camera.x, maxCameraX)); camera.y = Math.max(0, Math.min(camera.y, maxCameraY)); }

        // --- Drawing --- (same functions)
        function lerpColor(color1, color2, factor) { factor = Math.max(0, Math.min(1, factor)); const r1 = parseInt(color1.substring(1, 3), 16); const g1 = parseInt(color1.substring(3, 5), 16); const b1 = parseInt(color1.substring(5, 7), 16); const r2 = parseInt(color2.substring(1, 3), 16); const g2 = parseInt(color2.substring(3, 5), 16); const b2 = parseInt(color2.substring(5, 7), 16); const r = Math.round(r1 + (r2 - r1) * factor); const g = Math.round(g1 + (g2 - g1) * factor); const b = Math.round(b1 + (b2 - b1) * factor); return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`; }
        function drawWorld() { const startTileX = Math.floor(camera.x / TILE_SIZE); const endTileX = Math.ceil((camera.x + canvas.width) / TILE_SIZE); const startTileY = Math.floor(camera.y / TILE_SIZE); const endTileY = Math.ceil((camera.y + canvas.height) / TILE_SIZE); const clampedStartTileX = Math.max(0, startTileX); const clampedEndTileX = Math.min(WORLD_WIDTH_TILES, endTileX); const clampedStartTileY = Math.max(0, startTileY); const clampedEndTileY = Math.min(WORLD_HEIGHT_TILES, endTileY); for (let y = clampedStartTileY; y < clampedEndTileY; y++) { for (let x = clampedStartTileX; x < clampedEndTileX; x++) { const blockType = world[y][x]; if (blockType !== BLOCK_TYPES.AIR) { const blockScreenX = x * TILE_SIZE - camera.x; const blockScreenY = y * TILE_SIZE - camera.y; ctx.fillStyle = BLOCK_COLORS[blockType]; if (blockType === BLOCK_TYPES.LEAVES) ctx.globalAlpha = 0.85; ctx.fillRect(blockScreenX, blockScreenY, TILE_SIZE, TILE_SIZE); ctx.globalAlpha = 1.0; if (blockType === BLOCK_TYPES.DIRT || blockType === BLOCK_TYPES.STONE || blockType === BLOCK_TYPES.WOOD) { ctx.fillStyle = 'rgba(0,0,0,0.05)'; for(let i = 0; i < (blockType === BLOCK_TYPES.WOOD ? 2: 3); i++){ ctx.fillRect(blockScreenX + Math.random() * TILE_SIZE * 0.8, blockScreenY + Math.random() * TILE_SIZE * 0.8, 2, 2); } } if (blockType === BLOCK_TYPES.STONE) { ctx.fillStyle = 'rgba(255,255,255,0.05)'; for(let i = 0; i < 2; i++){ ctx.fillRect(blockScreenX + Math.random() * TILE_SIZE * 0.8, blockScreenY + Math.random() * TILE_SIZE * 0.8, 3, 3); } } if (blockType === BLOCK_TYPES.WOOD) { ctx.fillStyle = 'rgba(0,0,0,0.08)'; ctx.fillRect(blockScreenX + TILE_SIZE * 0.2, blockScreenY, TILE_SIZE * 0.1, TILE_SIZE); ctx.fillRect(blockScreenX + TILE_SIZE * 0.7, blockScreenY, TILE_SIZE * 0.1, TILE_SIZE); } if (blockType === BLOCK_TYPES.LEAVES) { ctx.fillStyle = 'rgba(0,0,0,0.1)'; for(let i = 0; i < 4; i++){ ctx.fillRect(blockScreenX + Math.random() * TILE_SIZE * 0.9, blockScreenY + Math.random() * TILE_SIZE * 0.9, 1, 1); } } if (blockType === BLOCK_TYPES.COPPER || blockType === BLOCK_TYPES.IRON || blockType === BLOCK_TYPES.GOLD) { ctx.fillStyle = 'rgba(255, 255, 255, 0.3)'; for(let i = 0; i < 3; i++){ ctx.fillRect(blockScreenX + Math.random() * TILE_SIZE * 0.7 + TILE_SIZE * 0.1, blockScreenY + Math.random() * TILE_SIZE * 0.7 + TILE_SIZE * 0.1, 2, 2); } ctx.fillStyle = 'rgba(0, 0, 0, 0.1)'; ctx.fillRect(blockScreenX + Math.random() * TILE_SIZE * 0.5, blockScreenY + Math.random() * TILE_SIZE * 0.5, TILE_SIZE*0.5, TILE_SIZE*0.5); } if (blockType === BLOCK_TYPES.GRASS) { ctx.fillStyle = BLOCK_COLORS[BLOCK_TYPES.DIRT]; ctx.fillRect(blockScreenX, blockScreenY + TILE_SIZE * 0.3, TILE_SIZE, TILE_SIZE * 0.7); ctx.fillStyle = BLOCK_COLORS[BLOCK_TYPES.GRASS]; ctx.fillRect(blockScreenX, blockScreenY, TILE_SIZE, TILE_SIZE * 0.3); ctx.fillStyle = 'rgba(255,255,255,0.2)'; ctx.fillRect(blockScreenX + TILE_SIZE * 0.2, blockScreenY, 1, 3); ctx.fillRect(blockScreenX + TILE_SIZE * 0.7, blockScreenY, 1, 4); } ctx.strokeStyle = 'rgba(0,0,0,0.1)'; ctx.strokeRect(blockScreenX, blockScreenY, TILE_SIZE, TILE_SIZE); } } } }
        function drawPlayer() { const playerScreenX = player.x - camera.x; const playerScreenY = player.y - camera.y; if (player.invulnerableTimer > 0 && Math.floor(player.invulnerableTimer / 5) % 2 === 0) { ctx.globalAlpha = 0.5; } const headSize = player.width * 0.6; const bodyHeight = player.height - headSize; const bodyWidth = player.width * 0.7; ctx.fillStyle = '#c00'; ctx.fillRect(playerScreenX + (player.width - bodyWidth) / 2, playerScreenY + headSize, bodyWidth, bodyHeight); ctx.fillStyle = '#f00'; ctx.beginPath(); ctx.arc(playerScreenX + player.width / 2, playerScreenY + headSize / 2, headSize / 2, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = 'white'; ctx.fillRect(playerScreenX + player.width / 2 - headSize * 0.2, playerScreenY + headSize * 0.3, 2, 2); ctx.fillRect(playerScreenX + player.width / 2 + headSize * 0.1, playerScreenY + headSize * 0.3, 2, 2); ctx.globalAlpha = 1.0; }
        function drawHighlight() { const tileWorldX = mouseTile.x * TILE_SIZE; const tileWorldY = mouseTile.y * TILE_SIZE; const tileScreenX = tileWorldX - camera.x; const tileScreenY = tileWorldY - camera.y; const dx = (player.x + player.width / 2) - (tileWorldX + TILE_SIZE / 2); const dy = (player.y + player.height / 2) - (tileWorldY + TILE_SIZE / 2); const distance = Math.sqrt(dx * dx + dy * dy); const distanceInTiles = distance / TILE_SIZE; if (distanceInTiles <= REACH_DISTANCE_TILES) ctx.strokeStyle = 'yellow'; else ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)'; ctx.lineWidth = 2; ctx.strokeRect(tileScreenX, tileScreenY, TILE_SIZE, TILE_SIZE); ctx.lineWidth = 1; }

        // --- Update Inventory Display --- (same updateInventoryDisplay)
        function updateInventoryDisplay() { inventoryDisplayDiv.innerHTML = `<span>🧱흙:${inventory[BLOCK_TYPES.DIRT]||0}</span>|<span>🪨돌:${inventory[BLOCK_TYPES.STONE]||0}</span>|<span>🪵나무:${inventory[BLOCK_TYPES.WOOD]||0}</span>|<span style="color:${BLOCK_COLORS[BLOCK_TYPES.COPPER]}">⛏️구리:${inventory[BLOCK_TYPES.COPPER]||0}</span>|<span style="color:${BLOCK_COLORS[BLOCK_TYPES.IRON]}">⛏️철:${inventory[BLOCK_TYPES.IRON]||0}</span>|<span style="color:${BLOCK_COLORS[BLOCK_TYPES.GOLD]}">⛏️금:${inventory[BLOCK_TYPES.GOLD]||0}</span>`; }

        // --- Game Loop --- (same update, gameLoop)
        function update() { if (isGameOver) return; gameTime++; if (!player.onGround) player.vy += GRAVITY; handleInput(); handleCollisions(); updateCamera(); updateParticles(); updateClouds(); updateEnemies(); if (gameTime % ENEMY_SPAWN_RATE === 0) { spawnEnemy(); } mouseWorldPos.x = mouseScreenPos.x + camera.x; mouseWorldPos.y = mouseScreenPos.y + camera.y; mouseTile.x = Math.floor(mouseWorldPos.x / TILE_SIZE); mouseTile.y = Math.floor(mouseWorldPos.y / TILE_SIZE); const currentBlockType = getTile(mouseWorldPos.x, mouseWorldPos.y); blockInfoDiv.textContent = `마우스: (${mouseTile.x}, ${mouseTile.y}) | 블록: ${BLOCK_NAMES[currentBlockType]}`; updateInventoryDisplay(); coordsInfoDiv.textContent = `플레이어 좌표: (${Math.floor(player.x/TILE_SIZE)}, ${Math.floor(player.y/TILE_SIZE)})`; }
        function gameLoop() { update(); draw(); if (!isGameOver) { requestAnimationFrame(gameLoop); } }

        // --- Draw Function --- (same draw function with background fix)
        function draw() { const timeOfDay = (gameTime / 60) % DAY_CYCLE_LENGTH_SECONDS / DAY_CYCLE_LENGTH_SECONDS; let skyColor; const dayColor = '#87CEEB'; const sunsetColor = '#FFA07A'; const nightColor = '#000033'; if (timeOfDay < 0.4) skyColor = lerpColor(sunsetColor, dayColor, timeOfDay / 0.4); else if (timeOfDay < 0.5) skyColor = dayColor; else if (timeOfDay < 0.6) skyColor = lerpColor(dayColor, sunsetColor, (timeOfDay - 0.5) / 0.1); else if (timeOfDay < 0.9) skyColor = lerpColor(sunsetColor, nightColor, (timeOfDay - 0.6) / 0.3); else skyColor = lerpColor(nightColor, sunsetColor, (timeOfDay - 0.9) / 0.1); ctx.clearRect(0, 0, canvas.width, canvas.height); ctx.fillStyle = skyColor; ctx.fillRect(0, 0, canvas.width, canvas.height); drawClouds(); drawWorld(); drawEnemies(); drawPlayer(); drawHighlight(); drawParticles(); let nightOpacity = 0; if (timeOfDay > 0.65 && timeOfDay < 0.9) nightOpacity = Math.min(0.6, (timeOfDay - 0.65) / 0.1); else if (timeOfDay >= 0.9 || timeOfDay < 0.1) nightOpacity = Math.max(0, 0.6 - (timeOfDay >= 0.9 ? timeOfDay - 0.9 : timeOfDay + 0.1) / 0.15); if (nightOpacity > 0) { ctx.fillStyle = `rgba(0, 0, 20, ${nightOpacity})`; ctx.fillRect(0, 0, canvas.width, canvas.height); } }

        // --- Utility Functions --- (same rectsOverlap)
        function rectsOverlap(rect1, rect2) { return rect1.x < rect2.x + rect2.width && rect1.x + rect1.width > rect2.x && rect1.y < rect2.y + rect2.height && rect1.y + rect1.height > rect2.y; }

        // --- Event Listeners --- (Modified keydown listener)
        window.addEventListener('keydown', (e) => {
            // Use e.key (lowercase for consistency)
            const key = e.key.toLowerCase();
            keys[key] = true;
            // Prevent default scrolling behavior for WASD, space
            if (['w', 'a', 's', 'd', ' '].includes(key)) {
                e.preventDefault();
            }
        });
        window.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false; // Use lowercase here too
        });
        canvas.addEventListener('mousemove', (e) => { const rect = canvas.getBoundingClientRect(); mouseScreenPos.x = e.clientX - rect.left; mouseScreenPos.y = e.clientY - rect.top; });
        canvas.addEventListener('click', (e) => { if (isGameOver) return; if (!soundInitialized) initSounds(); const tileX = mouseTile.x; const tileY = mouseTile.y; const worldClickX = mouseWorldPos.x; const worldClickY = mouseWorldPos.y; let clickedEnemy = null; for (let i = enemies.length - 1; i >= 0; i--) { const enemy = enemies[i]; if (worldClickX >= enemy.x && worldClickX <= enemy.x + enemy.width && worldClickY >= enemy.y && worldClickY <= enemy.y + enemy.height) { clickedEnemy = enemy; break; } } if (clickedEnemy) { clickedEnemy.takeDamage(10); if (clickedEnemy.health <= 0) { const particleColor = clickedEnemy.type === 'zombie' ? '#5a6351' : '#34D399'; for (let i = 0; i < 10; i++) { breakParticles.push(new Particle(clickedEnemy.x + clickedEnemy.width / 2, clickedEnemy.y + clickedEnemy.height / 2, particleColor)); } if (soundInitialized) enemyDieSound.triggerAttackRelease('2n'); enemies.splice(enemies.indexOf(clickedEnemy), 1); } } else { const dx = (player.x + player.width / 2) - (tileX * TILE_SIZE + TILE_SIZE / 2); const dy = (player.y + player.height / 2) - (tileY * TILE_SIZE + TILE_SIZE / 2); const distance = Math.sqrt(dx * dx + dy * dy); const distanceInTiles = distance / TILE_SIZE; if (distanceInTiles > REACH_DISTANCE_TILES) return; if (tileX >= 0 && tileX < WORLD_WIDTH_TILES && tileY >= 0 && tileY < WORLD_HEIGHT_TILES) { if (currentTool === 'break') { const blockToBreak = world[tileY][tileX]; if (blockToBreak !== BLOCK_TYPES.AIR) { const breakWorldX = tileX * TILE_SIZE + TILE_SIZE / 2; const breakWorldY = tileY * TILE_SIZE + TILE_SIZE / 2; const breakColor = BLOCK_COLORS[blockToBreak] || '#888'; if (blockToBreak === BLOCK_TYPES.DIRT || blockToBreak === BLOCK_TYPES.GRASS) inventory[BLOCK_TYPES.DIRT] = (inventory[BLOCK_TYPES.DIRT] || 0) + 1; else if (blockToBreak === BLOCK_TYPES.STONE) inventory[BLOCK_TYPES.STONE] = (inventory[BLOCK_TYPES.STONE] || 0) + 1; else if (blockToBreak === BLOCK_TYPES.WOOD) inventory[BLOCK_TYPES.WOOD] = (inventory[BLOCK_TYPES.WOOD] || 0) + 1; else if (blockToBreak === BLOCK_TYPES.COPPER) inventory[BLOCK_TYPES.COPPER] = (inventory[BLOCK_TYPES.COPPER] || 0) + 1; else if (blockToBreak === BLOCK_TYPES.IRON) inventory[BLOCK_TYPES.IRON] = (inventory[BLOCK_TYPES.IRON] || 0) + 1; else if (blockToBreak === BLOCK_TYPES.GOLD) inventory[BLOCK_TYPES.GOLD] = (inventory[BLOCK_TYPES.GOLD] || 0) + 1; world[tileY][tileX] = BLOCK_TYPES.AIR; for (let i = 0; i < 5; i++) breakParticles.push(new Particle(breakWorldX, breakWorldY, breakColor)); if (soundInitialized) breakSound.triggerAttackRelease('4n'); if (tileY < WORLD_HEIGHT_TILES - 1 && world[tileY + 1][tileX] === BLOCK_TYPES.DIRT && world[tileY][tileX] === BLOCK_TYPES.AIR) world[tileY + 1][tileX] = BLOCK_TYPES.GRASS; if (blockToBreak === BLOCK_TYPES.GRASS && tileY < WORLD_HEIGHT_TILES - 1 && world[tileY + 1][tileX] === BLOCK_TYPES.DIRT) world[tileY+1][tileX] = BLOCK_TYPES.GRASS; if (tileY > 0 && world[tileY-1][tileX] === BLOCK_TYPES.GRASS && blockToBreak !== BLOCK_TYPES.AIR) world[tileY-1][tileX] = BLOCK_TYPES.DIRT; } } else if (currentTool.startsWith('place_')) { if (selectedBlockToPlace === BLOCK_TYPES.COPPER || selectedBlockToPlace === BLOCK_TYPES.IRON || selectedBlockToPlace === BLOCK_TYPES.GOLD) { if (soundInitialized) cantPlaceSound.triggerAttackRelease('C3', '8n'); return; } if ((inventory[selectedBlockToPlace] || 0) <= 0) { if (soundInitialized) cantPlaceSound.triggerAttackRelease('C3', '8n'); return; } const playerRect = { x: player.x, y: player.y, width: player.width, height: player.height }; const blockRect = { x: tileX * TILE_SIZE, y: tileY * TILE_SIZE, width: TILE_SIZE, height: TILE_SIZE }; const overlaps = !(playerRect.x >= blockRect.x + blockRect.width || playerRect.x + playerRect.width <= blockRect.x || playerRect.y >= blockRect.y + blockRect.height || playerRect.y + playerRect.height <= blockRect.y); if (world[tileY][tileX] === BLOCK_TYPES.AIR && !overlaps) { let blockToPlaceActual = selectedBlockToPlace; if (selectedBlockToPlace === BLOCK_TYPES.DIRT) { if (tileY === 0 || world[tileY - 1][tileX] === BLOCK_TYPES.AIR) blockToPlaceActual = BLOCK_TYPES.GRASS; } world[tileY][tileX] = blockToPlaceActual; inventory[selectedBlockToPlace]--; if (soundInitialized) placeSound.triggerAttackRelease('G4', '8n'); if (tileY > 0 && world[tileY - 1][tileX] === BLOCK_TYPES.GRASS) world[tileY - 1][tileX] = BLOCK_TYPES.DIRT; } } } } });

        // --- Control Button Logic --- (same setActiveButton)
        function setActiveButton(activeBtn, toolName, blockType = null) { breakBtn.classList.remove('active'); placeDirtBtn.classList.remove('active'); placeStoneBtn.classList.remove('active'); placeWoodBtn.classList.remove('active'); activeBtn.classList.add('active'); statusInfoDiv.textContent = `현재 모드: ${toolName}`; if (blockType !== null) { currentTool = `place_${toolName}`; selectedBlockToPlace = blockType; } else { currentTool = 'break'; } }
        breakBtn.addEventListener('click', () => setActiveButton(breakBtn, '파괴'));
        placeDirtBtn.addEventListener('click', () => setActiveButton(placeDirtBtn, '흙 놓기', BLOCK_TYPES.DIRT));
        placeStoneBtn.addEventListener('click', () => setActiveButton(placeStoneBtn, '돌 놓기', BLOCK_TYPES.STONE));
        placeWoodBtn.addEventListener('click', () => setActiveButton(placeWoodBtn, '나무 놓기', BLOCK_TYPES.WOOD));

        // --- Start Game --- (same start logic)
        generateWorld();
        const startTileX = Math.floor(WORLD_WIDTH_TILES / 2); const startGroundY = Math.floor(WORLD_HEIGHT_TILES * 0.3); let initialPlayerY = (startGroundY - 5) * TILE_SIZE; for (let y = 0; y < WORLD_HEIGHT_TILES; y++) { if (isSolid(world[y][startTileX]) && !isSolid(world[y-1][startTileX]) && !isSolid(world[y-2][startTileX])) { initialPlayerY = (y - 2) * TILE_SIZE; break; } } player.x = startTileX * TILE_SIZE; player.y = initialPlayerY;
        updateCamera(); updateInventoryDisplay(); updateHealthUI();
        gameLoop();

    </script>
</body>
</html>
